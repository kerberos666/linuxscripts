#!/bin/bash
# by maravento.com

# Unifi Hotspot Client Access via Linux Server with Iptables
# v.1.0

# Diclaimer:
# This is an experimental script and depends on external components, such as dhcp, iptables, etc. Its operation is not guaranteed in Linux environments

# Howto
#https://www.maravento.com/2024/06/unifi-hotspot-con-iptables.html

# Tested with:
# - Vouchers generated by Hotspot on Unifi Network Server v.8.2.93
# - Ubuntu 22.04.x ​​x64 with iptables v1.8.7

# Installation on Ubuntu:
# https://get.glennr.nl/unifi/install/unifi-8.2.93.sh
# Update:
# https://get.glennr.nl/unifi/update/unifi-update.sh

#### WARNING
### Recommended settings in Unifi Network Server App
## On Hotspot Landing Page / Settings section:
#- On "Success Landing Page", select "Success Message" to allow capture "POST | success" authentication string
#- On "Pre-Authorization Allowances":  
# a. Do not add to this section: The IP address of your Linux server with iptables and/or the hotspot IP
# b. Add to this section: Network printers IPs (if you are going to share them with hotspot clients)
# c. Add to this section: Samba hostname (if you are going to share samba folders with hotspot clients. Additionally, you must enable netbios and ports in smb.conf and iptables)
#- Post-Authorization Restrictions: The network range you are going to work with should not be restricted in this section, as it affects the connection of clients. By default, this script works with the range 192.168.1.0/24, therefore you must remove 192.168.0.0/16 in this section.
## On Settings section / Wifi / Select Wifi Network (also apply in the configurations of the APs associated with the Hotspot): 
#- Uncheck Box: Client Device Isolation (only if you are going to share network printers or Samba shared folders with hotspot clients)
#- Uncheck Box: Multicast and Broadcast Control
#- Check Box: UAPSD (Optional)
#### END OF WARNING

echo "Unifi Hotspot for Iptables. Wait..."
printf "\n"

# checking root
if [ "$(id -u)" != "0" ]; then
    echo "This script must be run as root" 1>&2
    exit 1
fi

# checking script execution
if pidof -x $(basename $0) >/dev/null; then
    for p in $(pidof -x $(basename $0)); do
        if [ "$p" -ne $$ ]; then
            echo "Script $0 is already running..."
            exit
        fi
    done
fi

# ACL Path
MAC_LIST="/etc/acl/mac-hotspot.txt"
if [[ ! -f $MAC_LIST ]]; then
    mkdir -p "$(dirname "$MAC_LIST")"
    touch $MAC_LIST
    chmod 666 $MAC_LIST
fi &>/dev/null

# LOG path
LOG_FILE="/var/log/hotspot.log"
if [[ ! -f $LOG_FILE ]]; then
    touch $LOG_FILE
    chmod 666 $LOG_FILE
fi &>/dev/null

## Defines variable for the LAN interface. To find out your network interfaces, run:
## ip -o link | awk '$2 != "lo:" {print $2, $(NF-2)}' | sed 's_: _ _'
lan=eth1

# Iptables Path
iptables=/usr/sbin/iptables

# Linux Server IP
# replace the IP with that of your server
ipserver=192.168.1.1

# IP and Range assignment to Hotspot Clients
# IMPORTANT: Must match CIDR range set in configuration on Unifi Hotspot
IP="192.168.1"
RANGE_INI=160
RANGE_END=200

# Timestamp
# Expiration time in seconds (example: 1 minute = 60 seconds, 1 hour = 3600 seconds, etc.)
# IMPORTANT: It must coincide with the time assigned in the vouchers in Unifi Hotspot
expiration_seconds=3600

# Checking Rsyslog
function create_rsyslog_config() {
    local UNIFI_RSYSLOG="/etc/rsyslog.d/hotspot.conf"
    # Check if the rsyslog configuration file exists, if not, create it
    if [[ ! -f $UNIFI_RSYSLOG ]]; then
        echo "Creating rsyslog configuration if not exists..."
        touch $UNIFI_RSYSLOG
        echo ":msg, contains, \"HOTSPOT:\" /var/log/hotspot.log" >> $UNIFI_RSYSLOG
        echo "& stop" >> $UNIFI_RSYSLOG
        chmod 666 $UNIFI_RSYSLOG
        echo "rsyslog configuration created."
        systemctl restart rsyslog
        echo "rsyslog service restarted"
    else
        echo "rsyslog configuration already exists."
    fi
}
create_rsyslog_config

# unifi_rules
function unifi_rules() {
    # file for unifi_rules
    RULES_APPLIED_FILE="/var/run/iptables_rules_applied"

    # Check if the rules are already applied
    if [[ -f "$RULES_APPLIED_FILE" ]]; then
        if iptables-save | grep -q "success"; then
            echo "Rules already applied previously. They are not added again"
            return
        else
            echo "Removing stale rules file"
            rm "$RULES_APPLIED_FILE"
        fi
    fi

    # Open Unifi Ports
    # https://help.ui.com/hc/en-us/articles/218506997-UniFi-Network-Required-Ports-Reference
    echo "Opening Ports for Unifi"
    uports="3478,5514,8080,8880:8883,8843,8443,6789,27117,5656:5699,10001,1900"
    for protocol in tcp udp; do
        $iptables -t mangle -I PREROUTING -i $lan -d $ipserver -p $protocol -m multiport --dports $uports -j ACCEPT
        $iptables -I INPUT -i $lan -d $ipserver -p $protocol -m multiport --dports $uports -j ACCEPT
        $iptables -I FORWARD -i $lan -d $ipserver -p $protocol -m multiport --dports $uports -j ACCEPT
        $iptables -I OUTPUT -p $protocol -m multiport --dports $uports -j ACCEPT
    done
    
    # UniFi Hotspot String Capture
    $iptables -I INPUT -i $lan -p tcp --dport 8880 -m string --string "success" --algo bm -j LOG --log-prefix "HOTSPOT:"
    $iptables -I FORWARD -i $lan -p tcp --dport 8880 -m string --string "success" --algo bm -j LOG --log-prefix "HOTSPOT:"

    # Update file for unifi_rules
    iptables-save > "$RULES_APPLIED_FILE"
    echo "Rules applied and file $RULES_APPLIED_FILE updated."
}
unifi_rules

# Checking Timestamp (MACs in mac-hotspot.txt and removing expired)
function check_timestamps() {
    local current_time=$(date +'%s')
    local macs_to_remove=()

    while IFS= read -r line; do
        local timestamp=$(echo "$line" | awk -F';' '{print $4}' | awk -F'_' '{print $2}')
        if (( current_time - timestamp > expiration_seconds )); then
            macs_to_remove+=("$line")
            echo "Removing expired MAC: $line"
        fi
    done < "$MAC_LIST"

    for mac in "${macs_to_remove[@]}"; do
        sed -i "\|$mac|d" "$MAC_LIST"
    done
}
check_timestamps

function add_ports() {
    # Additional ports (Optional)
    # DNS PORTS: DNS (53), DNS over TLS DoT (853), Multicast DNS Bonjour-Apple, LLMNR-Microsoft, Avanhi-Linux and Link-Local Multicast LLMNR (5353), NTP (123), NETBios (137:139), Microsoft-DS and SMB (445), Open cups (printing service) udp/tcp for lan users IPP (631)
    echo "Opening Additional Ports"
    aports="53,853,5353,5355,123,137:139,445,631"
    for mac in $(awk -F";" '{print $2}' "$MAC_LIST"); do
        for protocol in tcp udp; do
            $iptables -t mangle -I PREROUTING -i $lan -p $protocol -m multiport --dports $aports -m mac --mac-source $mac -j ACCEPT
            $iptables -I INPUT -i $lan -p $protocol -m multiport --dports $aports -m mac --mac-source $mac -j ACCEPT
            $iptables -I FORWARD -i $lan -p $protocol -m multiport --dports $aports -m mac --mac-source $mac -j ACCEPT
            $iptables -I OUTPUT -p $protocol -m multiport --dports $aports -j ACCEPT
        done
    done
}

# Checking Iptables Rules (For MAC of authenticated clients)
function mac_rules() {
    echo "Applying Rules for Authenticated Clients..."

    # Remove existing rules for authenticated clients
    if [[ -f "$MAC_LIST" ]]; then
        for mac in $(awk -F";" '{print $2}' "$MAC_LIST"); do
            echo "Removing existing rules for MACs"
            $iptables -t mangle -D PREROUTING -i $lan -m mac --mac-source "$mac" -j ACCEPT 2>/dev/null
            $iptables -D INPUT -i $lan -m mac --mac-source "$mac" -j ACCEPT 2>/dev/null
            $iptables -D FORWARD -i $lan -m mac --mac-source "$mac" -j ACCEPT 2>/dev/null
        done
    else
        echo "MAC_LIST file does not exist: $MAC_LIST"
    fi

    # Apply new rules for authenticated clients
    if [[ -f "$MAC_LIST" ]]; then
        for mac in $(awk -F";" '{print $2}' "$MAC_LIST"); do
            echo "Adding rules for MACs"
            $iptables -t mangle -I PREROUTING -i $lan -m mac --mac-source "$mac" -j ACCEPT 2>/dev/null
            $iptables -I INPUT -i $lan -m mac --mac-source "$mac" -j ACCEPT 2>/dev/null
            $iptables -I FORWARD -i $lan -m mac --mac-source "$mac" -j ACCEPT 2>/dev/null
        done
    else
        echo "MAC_LIST file does not exist: $MAC_LIST"
    fi

    echo "Done"
}

# Generate random IP (within specified range)
function generate_random_ip() {
    echo "$IP.$((RANDOM % ($RANGE_END - $RANGE_INI + 1) + $RANGE_INI))"
}

# Generate random hostname (with Epoch Unix Timestamp)
function generate_random_hostname() {
    echo "host_$(date +'%s')"
}

# Add MAC with Timestamp to mac-hotspot.txt
function add_mac() {
    local mac="$1"
    local ip="$2"
    local hostname="$3"

    echo "a;$mac;$ip;$hostname" >> "$MAC_LIST"
    sort -u -o "$MAC_LIST" "$MAC_LIST"
}

# Checking MACs (is already registered)
function check_mac_existence() {
    local mac="$1"
    if grep -q "$mac" "$MAC_LIST"; then
    # If there are more lists to check
    #ANOTHER_MAC_LIST="$PATH_ACL/another_mac_list.txt"
    #if grep -q "$mac" "$MAC_LIST" || grep -q "$mac" "$ANOTHER_MAC_LIST"; then
        echo "$mac is already registered and will not be added"
    else
        add_mac "$mac" "$(generate_random_ip)" "$(generate_random_hostname)"
        echo "New hotspot client added: a;$mac;$(generate_random_ip);$(generate_random_hostname)"
        mac_rules
        #add_ports
    fi
}

# Capture LOG and extracting MACs
function process_logs() {
    if [[ -s "$LOG_FILE" ]]; then
        grep "HOTSPOT:" "$LOG_FILE" | while IFS= read -r line; do
            mac_address=$(echo "$line" | awk -F 'MAC=' '{print $2}' | awk -F ':' '{print $7":"$8":"$9":"$10":"$11":"$12}')
            echo "Processing LOG: $line"
            echo "MAC extracted: $mac_address"

            if [[ -n "$mac_address" ]]; then
                check_mac_existence "$mac_address"
            fi
        done
    else
        echo "empty LOG. No new MACs to process"
    fi
}
process_logs

# Clean LOG
truncate -s 0 "$LOG_FILE"

# restart DHCP
systemctl restart isc-dhcp-server
